## 작업 목록

- [x] 카드덱을 활용해서 게임을 위해 카드를 나눠주는 포커 게임 딜러와 카드를 받는 참가자를 설계하고, 각 역할을 담당하는 클래스 구현한다.
- [x] 카드 게임 규칙과 참가자 수에 따라서 각기 다른 방식으로 카드를 뽑아 전달한다
- [x] 딜러와 참가자를 포함하는 PokerGame 객체 작성
- [x] XCTest 단위 테스트 구현

## 학습 키워드

- Delegation Pattern
- Factory Pattern & Static method
- private initializer

### Diagram

<image src="../images/Protocol.png">

## 고민과 해결

### 문제

`PokerGame`은 `var player: [Gambler]` 배열을 가지고 있습니다. `Dealer` 는 해당 배열에 접근해 카드를 분배하는 역할을 합니다. 해당 배열을 어떤 방식으로 `Dealer` 전달해야할지에 대한 고민이 있었습니다.

- 시도 - 메소드의 인자로 배열을 넣는 방식을 고려했지만 `Dealer` 는 게임 진행의 전반적인 책임을 가지고 있어 해당 배열에 빈번하게 접근해야했기에 번거로운 방법이라는 생각이 들었습니다.
- 해결 - `Dealer` 메소드의 인자로 접근하는 것이 아닌 델리게이션 패턴을 이용해 `player` 배열에 접근하도록 수정하였습니다.
  - 델리게이션을 통해 접근하면 해당 배열의 생성과 관리의 책임을 위임할 수 있고 빈번하게 접근이 가능해지는 장점이 있어 델리게이션 패턴을 사용했습니다.

---

### 문제

델리게이션 프로토콜(`DealerDelegate`)의 요구사항으로 `var player: [Gambler]` 를 추가하였고 `PokerGame` 은 이 프로토콜을 채택하게 해두었습니다. 그 결과 `gameWillEnd` 메소드와 `players` 속성의 접근 범위가 `internal` 지정되어 인스턴스를 통해 접근을 허용하게 되었습니다.

- 시도 1 - 프로토콜의 요구사항에 modifier 를 추가해보았으나 불가능하다는 것을 알게 되었습니다.
- 시도 2 - 프로토콜 전체를 fileprivate 으로 설정하고 관련 코드를 하나의 파일에 작성하였지만 적절한 해결방법이 아니라는 생각이 들었습니다.
- 질문 - 델리게이션 패턴 사용 시 요구사항의 access level 은 private 하게 감추기 어려운 것 같습니다. 결국 지금의 구조가 델리게이션 패턴을 적용하기 적합한 구조가 아니라는 생각이 듭니다. JK 의 의견이 궁금합니다.
